# Memory Management 
## Topics 
- Borrowing & References 
- Lifetimes 

## Borrowing & References 
### Ownership
Rust uses the concept of ownership for memory management.  

Whoever has ownership of a variable, is in charge of cleaning it up when the owner goes out of scope. 
```rust 
#[derive(Debug)]
struct SomeStruct {
	num: i32,
}
```
Note: The derive macro generates an implementation of the trait is passed in. 

```rust
fn print_some_struct(the_struct: SomeStruct) {
	println!("{:?}", the_struct);
}
```

By default in Rust when a variable is passed to a function, the function takes ownership of the variable. 

This means that in the code below, the variable `some_struct` is passed out of the `main()` scope and into the first `print_some_struct` scope. Once the function runs, the `some_struct` variable is de-allocated from memory. 
```rust 
fn main() {
	let some_struct = SomeStruct { num: 3 };
	print_some_struct(some_struct); // Ok 
	print_some_struct(some_struct); // Error
}
```

## To Be Continued 